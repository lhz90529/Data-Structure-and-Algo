63. Unique Paths II ---> Follow up of 62.Unique Paths
Tag: Array, Dynamic Programming
Input: m-by-n gird filled with 0 and 1
Output: The number of UNIQUE path from the top left to bottom right;
Constrains:
	   0 is an empty space where you can move to
	   1 is where the obstacle is;
	   You can move either down or right 
	
Basic idea:
	Dynamic Programming
	Initialize a table to record the number of unique paths to each column of first row;
	Update table row by row such that we will end up with a table to record the number of unique paths to each column of the last row;

Pseudo code:
special case:
	If we found that gird[0][0] = 1, there is no way to reach any other point of the grid, we can simply return 0;
general cases:
	First: check if your current accessing point is 1:
		There is no way to reach (x,y) if grid[x][y] == 1 for any point (x,y) in the grid;
	Otherwise:
		table[i] = table[i] + table[i-1];

Temporal cost: O(m * n)
Spatial cost: O(n)
	