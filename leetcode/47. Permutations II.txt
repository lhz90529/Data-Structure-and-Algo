47. Permutations II
Input: a collection of numbers that might contain DUPLICATES;
Output: return all possible UNIQUE permuatations;

e.g.
[1,1,2] have the following unique permutations:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

Basic idea:
	Sort the input array (the pool) such that duplicates will cluster
	recursion + backtracking
	
Pseudo code:
Important variable declaration and explanation:
	chosen: a container to record all decisions we have made sofar
1: Sort the pool
2: Do recursion
Base case:
	if pool is empty, i.e. nothing can be selected from pool
		push "chosen" into our final solution set;
Recursive case:
	For each number in the pool
	Important check:
		if( i > 0 && nums[i] = nums[i-1])
			continue;
	exp: if we are accessing a non-first element of pool, and if it's as same as the previous element, we skip it;
		Making decision:
			1: declare a temporal variable "temp" to store the choice we are going to made
			2: push the choice into "chosen"
			3: pop out the choice from pool
		Explore: recursive call
		Backtracking: ---> undo all decisions we made
			1: pop out choice from "chosen"
			2" insert choice back into pool with CORRECT position
