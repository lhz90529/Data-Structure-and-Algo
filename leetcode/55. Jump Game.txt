55. Jump Game
Tag: Array, Greedy
Input: An array of non-negative integers --->non-negative means you cannot jump backwards
	   Each element in the array represents your maximum jump length at that position.
Output: You start with index 0, return if we can reach the last index;

Basic idea:
	We are initially start from index 0;
	We denote all index between 0 and n-1 as transfer station;
	As we explore each transfer station, we check iff we can reach this transfer station,
	if we can, figure out if we can reach destination from this transfer station;
				
				e.g.   source ---> transfer station i ----> destination
					   start              via                   to    
	   
Even though we cannot reach destination directly, but we can reach transfer station i, and that transfer station will lead us to the destination;

Pseudo code:
Variable declaration and explanation:
declare a variable called "farest", and initialize it with value 0; The farest we can reach from index starting point, i.e. 0;

For each transfer station ---> O(N) at WORST
	check if we can reach this transfer station
		if we can,
			1: get the farest index we can reach if we start from this transfer station;
				i.e. i + nums[i]
			2: if a new farest index is found,
				update farest;
			3: check if we can reach destination after we update farest
		else ---> we cannot reach this transfer station
			no need to explore further, since it must be true that you cannot reach the following transfer station;
			
The algorithm above may is the most optimal solution that I could come up;
Temporal Cost: O(N) AT WORST 
Spatial Cost: O(1);
			  	