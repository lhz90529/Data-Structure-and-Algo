62. Unique Paths
Tag: Array, Dynamic Programming
Input: int m, int n, where m and n represent a 2D m-by-n gird
Output: How many unique paths are there from top-left (0,0) to bottom right(m-1,n-1)?
Constrians:
	Each time you can either move down or right;

Basic idea:
	recursion ---> each recursive call will make a decision
	go down or go right?

Pseudo code:
Base cases:
	1:if you reach (m-1,n-1),return 1;
	2:if you reach the most right column, you can only move down;
	3:if you reach the most bottom row, you can only move right;
Recursive case:
	return the # of unique path if you move down + # of unique path if you move right;
HOWEVER, this recursive way is not very efficient;

For example: if m = 2 and n = 3;
					we start from here
							(0,0)
			(0,1)								(1,0)
	(0,2)			 (1,1)				(1,1)				(2,0)
(0,3)	(1,2)	(1,2)	(2,1)		(1,2)	(2,1)	   (2,1)   (2,1)

and so on...
We can easily find that there are a lot of duplicates call here;
--------------------------------------------------------------------------
Here, we start to tackle this problem by Dynamic Programming 

If we give a little bit more inspection to this problem, we found that there is only one path to reach the first column, and there is only 1 path to reach the first row;
table[i][j] is the number of unique path to reach (i,j);
	then tablep[i][j] = 1 for all i = 1, or j = 1
	For all other position with row >= 1 && col >=1,
		table[row][col] = talbe[row - 1][col] + table[row][col - 1]
							top of (row,col)     left of (row, col)
Becasue you can move from the top to the current location, or you can move from the left to current location;

Temporal cost: O(m*n);
Spatial cost: O(m*n); ---> DP table;
--------------------------------------------------------------------------
Try to improve the memory cost

We can define a new table with only n element, instead of m*n
Initially table contains all 1, like:
										talbe = [1,1,1 ... 1]
The interpretation is following:
	table records the number of unique path to reach all column of the first row;
	e.g. table[0] is the number of unique path to reach (0,0);

We update table row by row
For each row start from 1, ---> since we already know everything of row = 0;
		For each column 'i' start from 1, ---> since we know that there is only one way to reach the column 0 for any arbitary row
			table[i] = table[i-1] + table[i];
		table[i-1] stands for: the number of unique path to reach the left of current position
		table[i] on the right of equal sign stands for the number of unique path to reach the top of current position;
End For
After the table finish updating the last row, we return the last element of table that is the number of unique path to reach the bottom right;

Temporal Complexity: still O(m*n)
Spatial Complexity: O(n);