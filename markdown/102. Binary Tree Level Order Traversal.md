## [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)
### Tags:
Tree, Breadth-first-search
### Input:
Given a binary tree
### Output:
- Return __the level order traversal__ of its nodes' values, i.e.
    - ___from left to right___
    - ___level by level___

### Constrains:
- None

### e.g.
    Given binary tree [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
    return its level order traversal as:
    [
      [3],
      [9,20],
      [15,7]
    ]
### Basic Idea:
- ___Key concept:___
    - ___preorder traversal:___
    - ___why is that?___
        - _Even though all traversal algorithms can guarantee that the left child will always be visited before right child_
        - But __Only preorder traversal__ can visit node level by level, from the top to the bottom
    - _We could implement preorder traversal __recursively__ or __iteratively___

### Pseudo Code:
- __Recursion:__
    - __two parameters__: current visiting node, and its corresponding level
    - __base case:__  current visiting node is NULL
    - __recursive case:__
        - visit the current node
            - if the container at the current level is not existed,
                - construct an empty container for certain level
            - push the current visiting node into the container at the level of current node 
        - visit the left-subtree
        - visit the right subtree
- __Iteration:__
    - Construct a stack, and push <root,0> into stack
    	- `<root,0> stands for <node, its corresponding level> `
    - As long as stack is not empty
        - get the top pair from the stack
        - visit the current node
            - if the container at the current level is not existed,
                - construct an empty container for certain level
            - push the current visiting node into the container at the level of current node    
        - save `<right child, level + 1>` into stack
        - save `<left child, level + 1>` into stack
    - End loop

### Amortized Analysis:
- __Temporal: O(N) ---> Traverse the whole tree__ 
- __Spatial:__
    - __recursive: cost of stack taken by function calls__
    - __iterative: maybe O(N), need further mathmatical prove__ 
    
### Code:
- __Recursive:__

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        helper(root, 0, ret);
        return ret;
    }

private:
    void helper(TreeNode* current, int level, vector<vector<int>>& ret){
        if (current == NULL) {
            return;
        } else {
            //visit the node
            if(ret.size() == level){
                ret.push_back(vector<int>());
            }
            ret[level].push_back(current->val);
            helper(current->left, level + 1, ret);//move to left-subtree
            helper(current->right, level + 1, ret);//move to right-subtree
        }
    }
};
``` 
- __Iterative:__
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        stack<pair<TreeNode*, int>> mystack;//<TreeNode*, its corresponding depth>
        mystack.push({root,0});
        pair<TreeNode*, int> current;
        while (!mystack.empty()) {
            current = mystack.top();
            mystack.pop();
            if(current.first != NULL){//if the current accessing node is not NULL
                if (ret.size() == current.second) {//if the container at certain level is not exsited yet
                    ret.push_back(vector<int>());//construct an empty container
                }
                ret[current.second].push_back(current.first->val);//visit it
                //push the right child first such that later the left child will be visited first
                mystack.push({current.first->right, current.second + 1});
                mystack.push({current.first->left, current.second + 1});
            }
        }
        return ret;
    }
};
``` 